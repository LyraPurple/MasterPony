---------------
Tables relationnelles en Doctrine

---------------


2 tables à connecter
---------------


php bin/console make:entity

User
no
no

---------------
php bin/console make:entity
Product
user
?

ManyToOne
no

---------------

php bin/console make:migration
php bin/console doctrine:migrations:migrate


On vide la table car notre table produit en cours ne correspond pas au nouveau modèle relationnel (avec une nouvelle colonne vide avec des valeursn ull, alors que ça ne doit pas être nul)

php bin/console doctrine:database:drop --force

Puis on recréé la base

php bin/console doctrine:database:create

On fait notre migration
php bin/console doctrine:migrations:migrate

Si on a des problèmes, on drop tout, et on supprime al mano les fichiers de migration : src > Migrations > (fichiay de migrations) .php


--------------- Commandes équivalantes
php bin/console doctrine:schema:update --force

----- Ou cette commande seule, ou ces deux commandes qui permettent de voire ce qu'il se passe.

php bin/console make:migration

php bin/console doctrine:migrations:migrate

---------------
Changer dans config > packages > doctrine.yaml les tables en utf8.

On créé les users avant les produits car les produits ont besoin de user pour exister.
AppFixtures.php

$users = []; // Le tableau nous aide à retrouver les utilisateurs
for($i = 1; $i <= 10; $i++) {
	$user = new User();
	$user->SetUsername($faker->userName);
	$manager->persist($user);
	$users[$i] = $user;
}

---------------
php bin/console doctrine:fixtures:load


list.html.twig
Produit vendu par {{ product.user.username }}
Revient à écrire: $product->getUser()->getUsername();
On peut remarquer que Doctrine fait autant de requête qu'il n'y a d'utilisateurs.

Au niveau des performances, c'est moins performant que lorsqu'on le fait al mano nous-même. Au niveau simplicité, on roule Raoûl! Tût tût !


---------------




OneToMany est obligatoirement accompagné par  mappedBy="..."
	/**
    * @ORM\OneToMany(targetEntity="App\Entity\Product", mappedBy="user")
    */

Et il est préférable de préciser inversedBy sur le ManyToOne
	/**
    * @ORM\ManyToOne(targetEntity="App\Entity\User", inversedBy="products")
    */
